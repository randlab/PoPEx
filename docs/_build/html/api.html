

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API of PoPEx Package &mdash; PoPEx 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to PoPEx’s documentation!" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PoPEx
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API of PoPEx Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-popex.algorithm">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-popex.utils">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-popex.popex_objects">Classes</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PoPEx</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API of PoPEx Package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-of-popex-package">
<h1>API of PoPEx Package<a class="headerlink" href="#api-of-popex-package" title="Permalink to this headline">¶</a></h1>
<p>The API Documentation of the package</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">popex</span></code></p>
<div class="section" id="module-popex.algorithm">
<span id="algorithm"></span><h2>Algorithm<a class="headerlink" href="#module-popex.algorithm" title="Permalink to this headline">¶</a></h2>
<p><cite>algorithm.py</cite> contains the main implementation of the parallel (multiple-
chain) PoPEx algorithm. Mainly this concerns the two functions</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#popex.algorithm.run_popex_mp" title="popex.algorithm.run_popex_mp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_popex_mp()</span></code></a>: Main implementation for PoPEx runs</li>
<li><a class="reference internal" href="#popex.algorithm.pred_popex_mp" title="popex.algorithm.pred_popex_mp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pred_popex_mp()</span></code></a>: Main implementation for PoPEx predictions</li>
</ul>
</div></blockquote>
<p>that are used to sample models and predict results. A common file structure for
a PoPEx run together with some predictions is the following:</p>
<blockquote>
<div><div class="line-block">
<div class="line">&lt;path_res&gt;$</div>
<div class="line-block">
<div class="line">├– hd</div>
<div class="line-block">
<div class="line">└– hd_modXXXXXX.txt</div>
</div>
<div class="line">├– model</div>
<div class="line-block">
<div class="line">└– modXXXXXX.mod</div>
</div>
<div class="line">├– solution</div>
<div class="line-block">
<div class="line">├– run_&lt;name&gt;_modXXXXXX</div>
<div class="line">└– pred_&lt;name&gt;_modXXXXXX</div>
</div>
<div class="line">├– run_info.txt</div>
<div class="line">├– run_progress.txt</div>
<div class="line">├– pred_progress.txt</div>
<div class="line">├– popex.pop</div>
<div class="line">└– problem.pb</div>
</div>
</div>
</div></blockquote>
<p>The content of the different files is:</p>
<blockquote>
<div><ul class="simple">
<li><cite>hd_modXXXXXX.txt</cite>:             Hard conditioning (without prior hd)</li>
<li><cite>modXXXXXX.mod</cite>:                Pickled model object</li>
<li><cite>run_&lt;name&gt;_modXXXXXX.txt</cite>:     Info from forward operator</li>
<li><cite>pred_&lt;name&gt;_modXXXXXX.txt</cite>:    Info from prediction operator</li>
<li><cite>run_info.txt</cite>:                 Info about the sampling</li>
<li><cite>run_progress.txt</cite>:             Progress summary about the sampling</li>
<li><cite>pred_progress.txt</cite>:            Progress summary about the predictions</li>
<li><cite>popex.pop</cite>:                    Pickled PoPEx object</li>
<li><cite>problem.pb</cite>:                   Pickled Problem object</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="popex.algorithm.pred_popex_mp">
<code class="descclassname">popex.algorithm.</code><code class="descname">pred_popex_mp</code><span class="sig-paren">(</span><em>pred</em>, <em>path_res</em>, <em>nmp=1</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.algorithm.pred_popex_mp" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>pred_popex_mp</cite> is the main implementation for computing predictions
from a PoPEx sampling.</p>
<p class="rubric">Notes</p>
<p>The computations are supposed to be independent, such that they can be
computed in parallel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pred</strong> (<a class="reference internal" href="#popex.popex_objects.Prediction" title="popex.popex_objects.Prediction"><em>Prediction</em></a>) – Defines the prediction functions and parameters</li>
<li><strong>path_res</strong> (<em>str</em>) – Path for loading the PoPEx results</li>
<li><strong>nmp</strong> (<em>int</em>) – Number of parallel processes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.algorithm.run_popex_mp">
<code class="descclassname">popex.algorithm.</code><code class="descname">run_popex_mp</code><span class="sig-paren">(</span><em>pb</em>, <em>path_res</em>, <em>path_q_cat</em>, <em>ncmax=(20</em>, <em>)</em>, <em>nmp=1</em>, <em>nmax=1000</em>, <em>upd_hdmap_freq=1</em>, <em>upd_ls_freq=-1</em>, <em>si_freq=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.algorithm.run_popex_mp" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>run_popex_mp</cite> is the main implementation of the PoPEx algorithm.</p>
<p>The algorithm expands a set of models until the defined stopping condition
is fulfilled. A pre-requirement of the method is that we know a prior
probability map that corresponds to a given set of categories (c.f.
<cite>q_cat</cite>).</p>
<p class="rubric">Notes</p>
<p>The prior and generation probability values should NEVER be considered as
true probability values according to the true distribution. They should
only be used in combination (as ratio r):</p>
<blockquote>
<div><cite>ratio(m) = rho(m) / phi(m)</cite>.</div></blockquote>
<p>This ratio is important in the importance sampling framework where we want
to compute weighted expectation values according to a set of generated
models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pb</strong> (<a class="reference internal" href="#popex.popex_objects.Problem" title="popex.popex_objects.Problem"><em>Problem</em></a>) – Defines the problem functions and parameters</li>
<li><strong>path_res</strong> (<em>str</em>) – Path to the ‘results’ folder</li>
<li><strong>path_q_cat</strong> (<em>str</em>) – Path to the prior probability maps <cite>q_cat</cite> such that the tuple of
<cite>nmtype</cite> objects can be loaded under ‘&lt;path_q_cat&gt;q_cat.prob’</li>
<li><strong>ncmax</strong> (<em>m-tuple</em>) – Maximal number of conditioning points for each model type</li>
<li><strong>nmp</strong> (<em>int</em>) – Number of parallel processes to use</li>
<li><strong>nmax</strong> (<em>int</em>) – Number of maximal models (stopping condition)</li>
<li><strong>upd_hdmap_freq</strong> (<em>int</em>) – Defines the frequency for updating the HD maps (<cite>kld</cite> and <cite>p_cat</cite>)</li>
<li><strong>upd_ls_freq</strong> (<em>int</em>) – Defines the frequency for updating the learning scheme (-1 for no
update)</li>
<li><strong>si_freq</strong> (<em>int</em>) – Defines the frequency of saving intermediate states (-1 for no
intermediate saves)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-popex.utils">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-popex.utils" title="Permalink to this headline">¶</a></h2>
<p><cite>utils.py</cite> contains utilities for performing a PoPEx sampling and computing
predictions:</p>
<dl class="docutils">
<dt>Category probabilities and kld maps</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.utils.compute_cat_prob" title="popex.utils.compute_cat_prob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_cat_prob()</span></code></a>:   Computes probability maps according to
categories</li>
<li><a class="reference internal" href="#popex.utils.update_cat_prob" title="popex.utils.update_cat_prob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_cat_prob()</span></code></a>:    Updates probability maps according to
categories</li>
<li><a class="reference internal" href="#popex.utils.compute_entropy" title="popex.utils.compute_entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_entropy()</span></code></a>:    Computes entropy of a probability map</li>
<li><a class="reference internal" href="#popex.utils.compute_kld" title="popex.utils.compute_kld"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_kld()</span></code></a>:        Computes kld of two probability maps</li>
</ul>
</dd>
<dt>Hard conditioning data</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.utils.generate_hd" title="popex.utils.generate_hd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_hd()</span></code></a>:        Computes the new hard conditioning data</li>
<li><a class="reference internal" href="#popex.utils.merge_hd" title="popex.utils.merge_hd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">merge_hd()</span></code></a>:           Merges prior and new hard conditioning data</li>
<li><a class="reference internal" href="#popex.utils.compute_ncmod" title="popex.utils.compute_ncmod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_ncmod()</span></code></a>:      Computes the number of conditioning points per
model type</li>
<li><a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code></a>:      Computes the likelihood weights (used for the
hard conditioning maps)</li>
</ul>
</dd>
<dt>Generic functions</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.utils.compute_w_pred" title="popex.utils.compute_w_pred"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_pred()</span></code></a>:     Computes the weights for the predictions</li>
<li><a class="reference internal" href="#popex.utils.compute_subset_ind" title="popex.utils.compute_subset_ind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_subset_ind()</span></code></a>: Computes the smallest number of indices that
cover a given percentage of a total weight</li>
<li><a class="reference internal" href="#popex.utils.write_hd_info" title="popex.utils.write_hd_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_hd_info()</span></code></a>:      Writes/saves hd information about each model</li>
<li><a class="reference internal" href="#popex.utils.write_run_info" title="popex.utils.write_run_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_run_info()</span></code></a>:     Appends information about models to run info
file</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="popex.utils.compute_cat_prob">
<code class="descclassname">popex.utils.</code><code class="descname">compute_cat_prob</code><span class="sig-paren">(</span><em>popex</em>, <em>weights</em>, <em>start=-1</em>, <em>stop=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_cat_prob" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_cat_prob</cite> computes the weighted category probabilities.</p>
<p>The models are obtained from <cite>popex.model</cite> and weighted by <cite>weights</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure (cf <cite>popex_objects.PoPEx</cite>)</li>
<li><strong>weights</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Relative weights of the models</li>
<li><strong>start</strong> (<em>int</em>) – <p>Defines the first model to take into account:</p>
<ul>
<li>-1: For starting at 0</li>
<li>N: For starting at <cite>max(N, 0)</cite></li>
</ul>
</li>
<li><strong>stop</strong> (<em>int</em>) – <p>Defines the last model to take into account</p>
<ul>
<li>-1: For stopping at <cite>popex.nmod</cite></li>
<li>N: For stopping at <cite>min(N, popex.nmo)</cite></li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A tuple of instances that describes the category probabilities for all
categorical model types.</p>
<p>If a model type i is not a subclass of <code class="docutils literal notranslate"><span class="pre">CatMType</span></code>, the corresponding
map is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. If a model is given by (<cite>CatModel_1</cite>, …,
<cite>CatModel_m</cite>) and the model values in <cite>CatModel_i</cite> are subdivided into
<cite>ncat_i</cite> categories, then the return value is a (<cite>CatProb_1</cite>, …,
<cite>CatProb_m</cite>) tuple where <cite>return[i].param_val</cite> is a <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> with
<cite>shape=(nparam_i, ncat_i)</cite>.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">m-tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_entropy">
<code class="descclassname">popex.utils.</code><code class="descname">compute_entropy</code><span class="sig-paren">(</span><em>p_cat</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_entropy</cite> computes the entropy of <cite>p_cat</cite>.</p>
<p>The entropy of a discrete probability distributions <cite>p = (p_1, …,p_s)</cite> is</p>
<blockquote>
<div><cite>H(p) = -sum_{i=1}^s p_i log( p_i )</cite>.</div></blockquote>
<p>Therefore, if the probability map <cite>p_cat</cite> is a <code class="docutils literal notranslate"><span class="pre">m-tuple</span></code> such that
<cite>p_cat[i].param_val</cite> is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nparam_i, nfac_i)</cite>, the
entropy is also an <code class="docutils literal notranslate"><span class="pre">m-tuple</span></code> where <cite>H[i].param_val</cite> being an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>
of <cite>shape=(nparam,)</cite>.</p>
<p class="rubric">Notes</p>
<p>Note that <cite>t*log(t) -&gt; 0</cite> as <cite>t -&gt; 0</cite>. Therefore, <cite>H(x) = 0</cite> wherever
<cite>p_i(x) = 0</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p_cat</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">CatProb</span></code> instances with <cite>p_cat[i].param_val</cite> being an
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nparam_i, nfac_i)</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Tuple of entropy maps<dl class="docutils">
<dt><cite>return[i]</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">ContParam</span></code></span></dt>
<dd>Return value <cite>i</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> if <cite>p_cat[i]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, otherwise
it is an instance of <code class="docutils literal notranslate"><span class="pre">ContParam</span></code></dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">m-tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_kld">
<code class="descclassname">popex.utils.</code><code class="descname">compute_kld</code><span class="sig-paren">(</span><em>p_cat</em>, <em>q_cat</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_kld" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_kld</cite> computes the Kullback-Leibler divergence (KLD) between
two category probability maps <cite>p_cat</cite> and <cite>q_cat</cite>.</p>
<p>The KLD between two discrete probability distributions <cite>p = (p_1, …,p_s)</cite>
and <cite>q = (q_1, …,q_s)</cite> is</p>
<blockquote>
<div><cite>KLD(p||q) = sum_{i=1}^s p_i log( p_i / q_i)</cite>.</div></blockquote>
<p>Therefore, if the probability maps <cite>p_cat</cite> and <cite>q_cat</cite> are <code class="docutils literal notranslate"><span class="pre">m-tuples</span></code> such
that <cite>p_cat[i].param_val</cite> and <cite>q_cat[i].param_val</cite> are <code class="docutils literal notranslate"><span class="pre">ndarrays</span></code> of
<cite>shape=(nparam_i, nfac_i)</cite>, the Kullback-Leibler divergence is also an
<code class="docutils literal notranslate"><span class="pre">m-tuple</span></code> where <cite>kld[i].param_val</cite> is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nparam,)</cite>.</p>
<p class="rubric">Notes</p>
<p>Note that <cite>t*log(t/a) -&gt; 0</cite> as <cite>t -&gt; 0</cite>. Therefore, we require that <cite>q_i(x)
= 0</cite> implies <cite>p_i(x) = 0</cite> in which case we can put <cite>kld(x) = 0</cite>. However,
due to the (inaccurate) numerical representation of the probability maps, it
is possible that <cite>q_i(x) = 0</cite> and <cite>p_i(x) &gt; 0</cite> (f.e. when <cite>q</cite> has been
approximated from a relative small set of models). In this case we enforce
<cite>q_i(x) = p_i(x)</cite> what leads to <cite>kld(x) = 0</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p_cat</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">CatProb</span></code> instances with <cite>p_cat[i].param_val</cite> being an
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nparam_i x nfac_i)</cite></li>
<li><strong>q_cat</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">CatProb</span></code> instances with <cite>q_cat[i].param_val</cite> being an
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nparam_i, nfac_i)</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Tuple of kld maps</p>
<dl class="docutils">
<dt><cite>return[i]</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">ContParam</span></code></span></dt>
<dd><p class="first last">Return value <cite>i</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> if <cite>p_cat[i]`</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, otherwise
it is an instance of <code class="docutils literal notranslate"><span class="pre">ContParam</span></code></p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">m-tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_ncmod">
<code class="descclassname">popex.utils.</code><code class="descname">compute_ncmod</code><span class="sig-paren">(</span><em>popex</em>, <em>meth_w_hd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_ncmod" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_ncmod</cite> computes, for each model type, the number of
conditioning points.</p>
<p>It is assumed that the number of hard data is restricted model type-wise.
Therefore, the number of conditioning points is also computed model
type-wise by sampling from an uniform random variable
<cite>~U(0, popex.ncmax[imtype])</cite>.</p>
<p class="rubric">Notes</p>
<p>Note that if the total sum of the likelihood values in <cite>popex.p_lik</cite> is
zero, <cite>ncmod</cite> is set to zero for each model type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>meth_w_hd</strong> (<em>dict</em>) – Method to compute hard conditioning weights (cf. <a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code></a>)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Number of conditioning points per model type</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">m-tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_subset_ind">
<code class="descclassname">popex.utils.</code><code class="descname">compute_subset_ind</code><span class="sig-paren">(</span><em>p_frac</em>, <em>weights</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_subset_ind" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_subset_ind</cite> computes the smallest index set that covers a given
percentage.</p>
<p>This means that the subset indices <cite>ind</cite> are such that</p>
<blockquote>
<div><cite>np.sum(weights[ind]) &gt;= p_frac * np.sum(weights)</cite>,</div></blockquote>
<p>or in other words <cite>weights[ind]</cite> covers at least a fraction of <cite>p_frac</cite> of
the total some of <cite>weights</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p_frac</strong> (<em>float</em>) – Coverage fraction in <cite>(0, 1]</cite></li>
<li><strong>weights</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nw</em><em>,</em><em>)</em>) – Non-negative weights</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Subset of indices</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_w_lik">
<code class="descclassname">popex.utils.</code><code class="descname">compute_w_lik</code><span class="sig-paren">(</span><em>popex</em>, <em>meth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_w_lik" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_w_lik</cite> returns the set of normalized likelihood values.</p>
<p>In practice, when the likelihood values must be represented by a floating
point number, it might be advantageous to compute approximations of <cite>L(m)</cite>.</p>
<p>There are several approximation possibilities that are implemented in this
version (specified in <cite>meth</cite>):</p>
<blockquote>
<div><ol class="loweralpha">
<li><p class="first">No approximation (<cite>meth={‘name’: ‘exact’}</cite> or <cite>meth=None</cite>):</p>
<p><cite>L(m) = exp( ‘log_p_lik’ )</cite></p>
</li>
<li><p class="first">Sqrt-unskewed (<cite>meth={‘name’: ‘exp_sqrt_log’}</cite>)</p>
<p><cite>L(m) ~ exp( -sqrt(-‘log_p_lik’ )</cite></p>
</li>
<li><p class="first">K-unskewed (<cite>meth={‘name’: ‘exp_sqrt_log’, ‘pow’: k}</cite>)</p>
<p><cite>L(m) ~ exp( - (-‘log_p_lik’)^k )</cite></p>
</li>
<li><p class="first">Inverse log (<cite>meth={‘name’: ‘inv_log’}</cite>)</p>
<p><cite>L(m) ~ 1 / ( 1-‘log_p_lik’ )</cite></p>
</li>
<li><p class="first">Inverse sqrt-log (<cite>meth={‘name’: ‘inv_sqrt_log’}</cite>)</p>
<p><cite>L(m) ~ 1 / ( 1+sqrt(-‘log_p_lik’) )</cite>.</p>
</li>
</ol>
</div></blockquote>
<p>As mentioned above, these techniques aim to unskew the likelihood values.</p>
<p class="rubric">Notes</p>
<p>This function is used in two different locations (with possibly two
different approximation techniques): for the learning
scheme in the PoPEx sampling and for computing predictions. While in first
case any approximation technique can be used, the latter choice might bias
the computation weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>meth</strong> (<em>dict</em>) – <p>Defines the approximation method to be used. Fields are</p>
<blockquote>
<div><ul>
<li><code class="docutils literal notranslate"><span class="pre">'name'</span></code> : Name of the method (<cite>str</cite>)</li>
<li><code class="docutils literal notranslate"><span class="pre">'pow'</span></code> : Power for method (c) (<cite>float</cite>)</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Array of normalized weights</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray, shape=(nmod,)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.compute_w_pred">
<code class="descclassname">popex.utils.</code><code class="descname">compute_w_pred</code><span class="sig-paren">(</span><em>popex</em>, <em>nw_min=0</em>, <em>ibnd=-1</em>, <em>meth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.compute_w_pred" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>compute_w_pred</cite> returns the set of normalized predictive weights.</p>
<p>For assuring a minimum number of effective weights, they are computed such
that</p>
<blockquote>
<div><cite>ne(w_pred) = min(nw_min, ne(w))</cite></div></blockquote>
<p>where <cite>w</cite> contains the weights associated to the models and <cite>ne(w)</cite> denotes
the number of effective weights. This quantity can be modified by replacing
<cite>w</cite> with <cite>w^lpha</cite>, where <cite>alpha &gt; 0</cite>. A <cite>1-d</cite> optimisation problem is used
to compute the optimal <cite>lpha</cite> value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>nw_min</strong> (<em>int</em>) – Mininum number of effective weights <cite>(= l_0)</cite></li>
<li><strong>ibnd</strong> (<em>int</em>) – Length of the weight array</li>
<li><strong>meth</strong> (<em>dict</em>) – <p>Defines the approximation method to be used (cf. <a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code></a>).
Fields are</p>
<blockquote>
<div><ul>
<li><code class="docutils literal notranslate"><span class="pre">'name'</span></code> : Name of the method (<cite>str</cite>)</li>
<li><code class="docutils literal notranslate"><span class="pre">'pow'</span></code> : Power for method (c) (<cite>float</cite>)</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Array of predictive weights</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray, shape=(nmod,)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.generate_hd">
<code class="descclassname">popex.utils.</code><code class="descname">generate_hd</code><span class="sig-paren">(</span><em>popex</em>, <em>meth_w_hd</em>, <em>ncmod</em>, <em>kld</em>, <em>p_cat</em>, <em>q_cat</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.generate_hd" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>generate_hd</cite> generates the hard conditioning data set that is used
to sample a new model.</p>
<p>This set of hard conditioning data does NOT include prior hard conditioning.
For each model type <cite>(imtype)</cite>, every hard conditioning is obtained by the
following 2-steps:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Sample a location <cite>[j]</cite> according to the values in the Kullback-
Leibler divergence map (i.e. the values in <cite>kld[imtype].param_val</cite>)</li>
<li>Sample a model <cite>[k]</cite> according to the weights from
<a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code></a> and directly extract the hard conditioning
value from <cite>popex.model[k][imtype].param_val[j]</cite>.</li>
</ol>
</div></blockquote>
<p>In addition to the hard conditioning, this function also extracts
probability values from <cite>q_cat</cite> and <cite>p_cat</cite> at the conditioning location.
These values represent the prior/weighted category probability of the
category that corresponds to <cite>popex.model[k][imtype].param_val[j]</cite>. They
can be useful to compute the sampling weight ratio.</p>
<p class="rubric">Notes</p>
<p>There are two important things to note:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The two objects <cite>hd_prior</cite> and <cite>hd_generation</cite> are the corresponding
prior and weighted probability values of the hard conditioning
CATEGORY that corresponds to the values in <cite>hd_param_val</cite>.
Therefore, if they are used in the computation of the sampling
weight ratio, one uses CATEGORY probabilities and NOT value
probabilities.</li>
<li>Numerical imperfections (for example in the computation of ‘q_cat’)
can cause locations where <cite>p_cat &gt; 0</cite> but <cite>q_cat = 0</cite>. In the
computation of the Kullback-Leibler divergence we did put
corresponding <cite>kld</cite> values to <cite>0</cite> (by enforcing <cite>q_i(x) = p_i(x)</cite>)
and therefore it is impossible to sample and condition such
locations.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>meth_w_hd</strong> (<em>dict</em>) – Method to compute hard conditioning weights (cf. <a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code></a>)</li>
<li><strong>ncmod</strong> (<em>m-tuple</em>) – Number of conditioning points per model type</li>
<li><strong>kld</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">ContParam</span></code> instances defining the Kullback-Leibler
divergence</li>
<li><strong>p_cat</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">CatProb</span></code> instances defining the weighted category
probabilities with <cite>p_cat[i].param_val</cite> being an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of
<cite>shape=(nparam_i, nfac_i)</cite></li>
<li><strong>q_cat</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">CatProb</span></code> instances defining the weighted category
probabilities with <cite>q_cat[i].param_val</cite> being an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of
<cite>shape=(nparam_i x nfac_i)</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>hd_param_ind</strong> (<em>m-tuple</em>) – Tuple of hard conditioning indices where hard conditioning values are
imposed. If there is no hard conditioning for a model type <cite>i</cite>, then
<cite>hd_ind[i]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise it is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of
<cite>shape=(ncmod[i], ndarray)</cite>.</li>
<li><strong>hd_param_val</strong> (<em>m-tuple</em>) – Tuple of hard conditioning values that are imposed at the hard
conditioning indices. If there is no hard conditioning for a model type
<cite>i</cite>, then <cite>hd_val[i]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise it is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of
<cite>shape=(ncmod[i], ndarray)</cite>.</li>
<li><strong>hd_prior</strong> (<em>m-tuple</em>) – Tuple of probability values according to the prior probability maps in
<cite>q_cat</cite>. Each value corresponds to the prior probability of the category
that contains the extracted hard conditioning value.  If there is no
hard conditioning for a model type <cite>i</cite>, then <cite>hd_val[i]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>
otherwise it is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(ncmod[i], ndarray)</cite>.</li>
<li><strong>hd_generation</strong> (<em>m-tuple</em>) – Tuple of probability values according to the sampling probability maps
in <cite>p_cat</cite>. Each value corresponds to the sampling probability of the
category that contains the extracted hard conditioning values. If there
is no hard conditioning for a model type <cite>i</cite>, then <cite>hd_val[i]</cite> is
<code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise it is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(ncmod[i], ndarray)</cite>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.merge_hd">
<code class="descclassname">popex.utils.</code><code class="descname">merge_hd</code><span class="sig-paren">(</span><em>hd_param_ind_1</em>, <em>hd_param_ind_2</em>, <em>hd_param_val_1</em>, <em>hd_param_val_2</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.merge_hd" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>merge_hd</cite> used for merging two sets of hard conditioning data.</p>
<p>It is assumed that <cite>hd_param_ind_i[imtype]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code> if and only if
<cite>hd_param_val_i[imtype]</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hd_param_ind_1</strong> (<em>m-tuple</em>) – First set of hard conditioning indices</li>
<li><strong>hd_param_ind_2</strong> (<em>m-tuple</em>) – Second set of hard conditioning indices</li>
<li><strong>hd_param_val_1</strong> (<em>m-tuple</em>) – First set of hard conditioning values</li>
<li><strong>hd_param_val_2</strong> (<em>m-tuple</em>) – Second set of hard conditioning values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>hd_ind</strong> (<em>m-tuple</em>) – Merged set of hard conditioning indices</li>
<li><strong>hd_par</strong> (<em>m-tuple</em>) – Merged set of hard conditioning values</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.update_cat_prob">
<code class="descclassname">popex.utils.</code><code class="descname">update_cat_prob</code><span class="sig-paren">(</span><em>p_cat</em>, <em>m_new</em>, <em>w_new</em>, <em>sum_w_old</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.update_cat_prob" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>update_cat_prob</cite> updates (in place) the category probabilities.</p>
<p>If <cite>p_cat_old</cite> represents the old category probability maps, then we have</p>
<blockquote>
<div><cite>p_cat_new = [sum_w_old*p_cat_old + sum_i w_new_i*1(m_new_i)]
/ [sum_w_old + sum(w_new)]</cite></div></blockquote>
<p>where <cite>1(m_new_i)</cite> is the categorical indicator of the model <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p_cat</strong> (<em>m-tuple</em>) – Tuple of categorical probability maps (cf. <a class="reference internal" href="#popex.utils.compute_cat_prob" title="popex.utils.compute_cat_prob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_cat_prob()</span></code></a>)</li>
<li><strong>m_new</strong> (<em>list</em>) – List of m-tuples defining a set of <cite>nmod</cite> models</li>
<li><strong>w_new</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Weights associated to the new models</li>
<li><strong>sum_w_old</strong> (<em>float</em>) – Old weight normalization constant</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.write_hd_info">
<code class="descclassname">popex.utils.</code><code class="descname">write_hd_info</code><span class="sig-paren">(</span><em>popex</em>, <em>imod</em>, <em>hd_param_ind</em>, <em>hd_param_val</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.write_hd_info" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>write_hd_info</cite> writes the hard conditioning that has been deduced
for creating a specific model to a text file.</p>
<div class="line-block">
<div class="line">The text file is saved at <cite>popex.path_res</cite> with the following structure:</div>
<div class="line-block">
<div class="line">&lt;popex.path_res&gt;$</div>
<div class="line-block">
<div class="line">└– hd</div>
<div class="line-block">
<div class="line">└– hd_modXXXXXX.txt</div>
</div>
</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>imod</strong> (<em>int</em>) – Model index</li>
<li><strong>hd_param_ind</strong> (<em>m-tuple</em>) – Hard conditioning indices</li>
<li><strong>hd_param_val</strong> (<em>m-tuple</em>) – Hard conditioning values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="popex.utils.write_run_info">
<code class="descclassname">popex.utils.</code><code class="descname">write_run_info</code><span class="sig-paren">(</span><em>pb</em>, <em>popex</em>, <em>imod</em>, <em>log_p_lik</em>, <em>cmp_log_p_lik</em>, <em>log_p_pri</em>, <em>log_p_gen</em>, <em>ncmod</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.utils.write_run_info" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>write_run_info</cite> writes some algorithm specific information to a text
file.</p>
<div class="line-block">
<div class="line">The text file is save at <cite>popex.path_res</cite> with the following structure:</div>
<div class="line-block">
<div class="line">&lt;popex.path_res&gt;$</div>
<div class="line-block">
<div class="line">└– run_info.txt</div>
</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pb</strong> (<a class="reference internal" href="#popex.popex_objects.Problem" title="popex.popex_objects.Problem"><em>Problem</em></a>) – Defines the problem functions and parameters</li>
<li><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure</li>
<li><strong>imod</strong> (<em>int</em>) – Model index</li>
<li><strong>log_p_lik</strong> (<em>float</em>) – Log-likelihood value of the model</li>
<li><strong>cmp_log_p_lik</strong> (<em>bool</em>) – Indicates if likelihood has been computed (True) or predicted (False)</li>
<li><strong>log_p_pri</strong> (<em>float</em>) – Prior log-probability of the model</li>
<li><strong>log_p_gen</strong> (<em>float</em>) – Sampling log-probability of the model</li>
<li><strong>ncmod</strong> (<em>m-tuple</em>) – Model type specific number of conditioning points used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-popex.popex_objects">
<span id="classes"></span><h2>Classes<a class="headerlink" href="#module-popex.popex_objects" title="Permalink to this headline">¶</a></h2>
<p>‘popex_objects.py’ contains the PoPEx-specific class definitions.</p>
<dl class="docutils">
<dt>Main structure</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><code class="xref py py-class docutils literal notranslate"><span class="pre">PoPEx</span></code></a>: Main class for any PoPEx simulation. It contains the
model chain and any corresponding probability measures.</li>
</ul>
</dd>
<dt>Sampling definitions</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.popex_objects.Problem" title="popex.popex_objects.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">Problem</span></code></a>: Defines the sampling parameters and functions</li>
<li><a class="reference internal" href="#popex.popex_objects.Learning" title="popex.popex_objects.Learning"><code class="xref py py-class docutils literal notranslate"><span class="pre">Learning</span></code></a>: Learning scheme for learning the likelihood values</li>
<li><a class="reference internal" href="#popex.popex_objects.Prediction" title="popex.popex_objects.Prediction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prediction</span></code></a>: Defines the prediction parameters and functions</li>
</ul>
</dd>
<dt>Classes associated to a model type</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#popex.popex_objects.MType" title="popex.popex_objects.MType"><code class="xref py py-class docutils literal notranslate"><span class="pre">MType</span></code></a>: (<cite>abstract</cite>) Parent class for each map associated to a
model type</li>
<li><a class="reference internal" href="#popex.popex_objects.ContParam" title="popex.popex_objects.ContParam"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContParam</span></code></a>: (inherits from <a class="reference internal" href="#popex.popex_objects.MType" title="popex.popex_objects.MType"><code class="xref py py-class docutils literal notranslate"><span class="pre">MType</span></code></a>) Class for each map that
is associated to the model types but not to categories (e.g.
<cite>kld[imtype]</cite>, <cite>entropy[imtype]</cite>)</li>
<li><a class="reference internal" href="#popex.popex_objects.CatMType" title="popex.popex_objects.CatMType"><code class="xref py py-class docutils literal notranslate"><span class="pre">CatMType</span></code></a>: (<cite>abstract</cite>, inherits from <a class="reference internal" href="#popex.popex_objects.MType" title="popex.popex_objects.MType"><code class="xref py py-class docutils literal notranslate"><span class="pre">MType</span></code></a>) Parent class
for each map that is associated to categories</li>
<li><a class="reference internal" href="#popex.popex_objects.CatProb" title="popex.popex_objects.CatProb"><code class="xref py py-class docutils literal notranslate"><span class="pre">CatProb</span></code></a>: (inherits from <a class="reference internal" href="#popex.popex_objects.CatMType" title="popex.popex_objects.CatMType"><code class="xref py py-class docutils literal notranslate"><span class="pre">CatMType</span></code></a>) This class is used for
the representation of probability distributions over categories
(e.g. <cite>p_cat[imtype]</cite>, <cite>q_cat[imtype]</cite>)</li>
<li><a class="reference internal" href="#popex.popex_objects.CatParam" title="popex.popex_objects.CatParam"><code class="xref py py-class docutils literal notranslate"><span class="pre">CatParam</span></code></a>: (inherits from <a class="reference internal" href="#popex.popex_objects.CatMType" title="popex.popex_objects.CatMType"><code class="xref py py-class docutils literal notranslate"><span class="pre">CatMType</span></code></a>) This class is used
for the representation of categorized parameter values (e.g.
<cite>model[j][imtype]</cite>)</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="popex.popex_objects.CatMType">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">CatMType</code><span class="sig-paren">(</span><em>dtype_val='float64'</em>, <em>param_val=None</em>, <em>categories=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.CatMType" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is the abstract parent of any quantity associated to a
categorical model type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dtype_val</strong> (<em>str</em>) – Type of the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> values (eg. ‘int8’, ‘float32’, ‘float64’, etc)</li>
<li><strong>param_val</strong> (<em>ndarray</em>) – Values associated to the parameters</li>
<li><strong>categories</strong> (<em>list</em>) – <p>List of size <cite>ncat</cite>. Each instance of the list is again a list
of 2-tuples that define the value range for the category.</p>
<p>If <cite>categories[i] = [(v_1, v_2), (v_3, v_4)]</cite>, where <cite>v_j</cite> are real
values, then the category <cite>i</cite> is defined by the union</p>
<blockquote>
<div><cite>[v_1, v_2) U [v_3, v_4)</cite></div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="popex.popex_objects.CatMType.ncat">
<code class="descname">ncat</code><a class="headerlink" href="#popex.popex_objects.CatMType.ncat" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of categories.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number of categories in <cite>categories</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.CatParam">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">CatParam</code><span class="sig-paren">(</span><em>dtype_val='float64'</em>, <em>param_val=None</em>, <em>categories=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.CatParam" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to define a categorized 1-dimensional parameter map
that is associated to a model type (e.g. <cite>model</cite>, etc). The categories of
each model parameter in <cite>param_val</cite> is indicated in <cite>param_cat</cite>. These
categories are automatically updated if <cite>param_val</cite> or <cite>categories</cite> change.</p>
<p class="rubric">Notes</p>
<p>The shape of <cite>param_val</cite> and <cite>param_cat</cite> is <cite>shape=(nparam,)</cite>.</p>
<dl class="attribute">
<dt id="popex.popex_objects.CatParam.param_cat">
<code class="descname">param_cat</code><a class="headerlink" href="#popex.popex_objects.CatParam.param_cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Category indicator array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Category indicators of the values in <cite>param_val</cite>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray, shape=(nparam,)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.CatProb">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">CatProb</code><span class="sig-paren">(</span><em>dtype_val='float64'</em>, <em>param_val=None</em>, <em>categories=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.CatProb" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to define a map of continuous values for each
category, where each value is associated to a model parameter (e.g. <cite>p_cat</cite>,
<cite>q_cat</cite>, etc.).</p>
<p class="rubric">Notes</p>
<p>The shape of <cite>param_val</cite> is <cite>shape=(nparam, ncat)</cite>.</p>
</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.ContParam">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">ContParam</code><span class="sig-paren">(</span><em>dtype_val='float64'</em>, <em>param_val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.ContParam" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to define a map of continuous values where each value
is associated to a model parameter (e.g. <cite>entropy</cite>, <cite>kld</cite>, etc.).</p>
<p class="rubric">Notes</p>
<p>The shape of <cite>param_val</cite> is <cite>(nparam,)</cite>.</p>
</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.Learning">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">Learning</code><a class="headerlink" href="#popex.popex_objects.Learning" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>Learning</cite> defines an abstract parent class for a learning scheme.</p>
<p>Let’s assume that we want to define a learning scheme that predicts the
log-likelihood of a model. In this case we define an explicite sub-class
of <code class="docutils literal notranslate"><span class="pre">Learning</span></code> and provide implementations of the methods</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#popex.popex_objects.Learning.train" title="popex.popex_objects.Learning.train"><code class="xref py py-meth docutils literal notranslate"><span class="pre">train()</span></code></a></li>
<li><a class="reference internal" href="#popex.popex_objects.Learning.compute_p_eval_for" title="popex.popex_objects.Learning.compute_p_eval_for"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_p_eval_for()</span></code></a></li>
<li><a class="reference internal" href="#popex.popex_objects.Learning.learn_value_of" title="popex.popex_objects.Learning.learn_value_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">learn_value_of()</span></code></a></li>
</ul>
</div></blockquote>
<p>It is assumed that there is a choice between ‘evaluating the exact
answer’ (which is very expensive) or ‘predicting the  answer by a machine
learning scheme’ (which should be very fast). The learning scheme undergoes
the following main steps</p>
<blockquote>
<div><ul class="simple">
<li>Update the learning scheme regularly by using the function
<code class="xref py py-meth docutils literal notranslate"><span class="pre">trian()</span></code> (cf. <cite>upd_ls_freq</cite> in <cite>algorithm.run_popex_mp</cite>). Note
that here you can choose to only use likelihood values that have
effectively been computed (cf. <cite>PoPEx.cmp_log_p_lik</cite>).</li>
<li>For a given instance compute a probability <cite>p in [0,1]</cite> with which
the log-likelihood is predicted or evaluated (cf.
<a class="reference internal" href="#popex.popex_objects.Learning.compute_p_eval_for" title="popex.popex_objects.Learning.compute_p_eval_for"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_p_eval_for()</span></code></a>) and then the value eventually is predicted
(cf. <a class="reference internal" href="#popex.popex_objects.Learning.learn_value_of" title="popex.popex_objects.Learning.learn_value_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">learn_value_of()</span></code></a>).</li>
</ul>
</div></blockquote>
<p class="rubric">Notes</p>
<p>In the PoPEx framework this can be used to learn the log-likelihood
values for each model (=value of interest). In this regard, predicting a
value rather than computing it can considerably improve the overall
computational time.</p>
<dl class="method">
<dt id="popex.popex_objects.Learning.compute_p_eval_for">
<code class="descname">compute_p_eval_for</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.Learning.compute_p_eval_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and return a probability value in [0, 1] that determines
whether a model should be evaluated exactly.</p>
<p>The two extreme confidence values signify:</p>
<blockquote>
<div><cite>p=0</cite>: Value can be learned from the learning scheme
<cite>p=1</cite>: Value should be evaluated exactly.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">Mtype</span></code> instances that define the new model</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Probability value in <cite>[0, 1]</cite></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="popex.popex_objects.Learning.learn_value_of">
<code class="descname">learn_value_of</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.Learning.learn_value_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the existing learning scheme to learn the value of interest for
an instance.</p>
<p class="rubric">Notes</p>
<p>This function should raise an error if there is no existing learning
scheme.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">Mtype</span></code> instances that define the new model</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Predicted log-likelihood value</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="popex.popex_objects.Learning.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>popex</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.Learning.train" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a learning scheme.</p>
<p>The learning scheme can be saved as class parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>popex</strong> (<a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><em>PoPEx</em></a>) – PoPEx main structure (cf <cite>popex_objects.PoPEx</cite>)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.MType">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">MType</code><span class="sig-paren">(</span><em>dtype_val='float64'</em>, <em>param_val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.MType" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is the parent of any quantity associated to a model type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dtype_val</strong> (<em>str</em>) – Type of the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> values (eg. ‘int8’, ‘float32’, ‘float64’, etc)</li>
<li><strong>param_val</strong> (<em>ndarray</em>) – Values associated to the parameters</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="popex.popex_objects.MType.nparam">
<code class="descname">nparam</code><a class="headerlink" href="#popex.popex_objects.MType.nparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number of values in <cite>param_val</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.PoPEx">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">PoPEx</code><span class="sig-paren">(</span><em>model=None</em>, <em>log_p_lik=array([]</em>, <em>dtype=float64)</em>, <em>cmp_log_p_lik=array([]</em>, <em>dtype=bool)</em>, <em>log_p_pri=array([]</em>, <em>dtype=float64)</em>, <em>log_p_gen=array([]</em>, <em>dtype=float64)</em>, <em>ncmax=(0</em>, <em>)</em>, <em>nc=None</em>, <em>nmtype=1</em>, <em>path_res='~/'</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.PoPEx" title="Permalink to this definition">¶</a></dt>
<dd><p>Main class for any PoPEx simulation.</p>
<p>This class is the main object for the PoPEx algorithm. It contains all
the models, likelihood, log-prior and log-generation information of a PoPEx
run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model</strong> (<em>list</em>) – <p>List of models</p>
<dl class="docutils">
<dt>model[j] <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Tuple of <code class="docutils literal notranslate"><span class="pre">MType</span></code> instances</dd>
</dl>
</li>
<li><strong>log_p_lik</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Natural logarithm of likelihood measure</li>
<li><strong>cmp_log_p_lik</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Boolean indicator whether the log-likelihood value has been computed
(True) or predicted (False)</li>
<li><strong>log_p_pri</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Natural logarithm of prior measure value</li>
<li><strong>log_p_gen</strong> (<em>ndarray</em><em>, </em><em>shape=</em><em>(</em><em>nmod</em><em>,</em><em>)</em>) – Natural logarithm of sampling measure value</li>
<li><strong>ncmax</strong> (<em>m-tuple</em>) – Maximum number of conditioning points for each model type</li>
<li><strong>nc</strong> (<em>list</em>) – <p>List of m-tuples</p>
<dl class="docutils">
<dt>nc[j] <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Contains the number of conditioning used conditioning points in the
generation of <cite>model[j]</cite></dd>
</dl>
</li>
<li><strong>nmtype</strong> (<em>int</em>) – Number of model types</li>
<li><strong>path_res</strong> (<em>str</em>) – Path of the results</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="popex.popex_objects.PoPEx.add_model">
<code class="descname">add_model</code><span class="sig-paren">(</span><em>imod</em>, <em>model</em>, <em>log_p_lik</em>, <em>cmp_log_p_lik</em>, <em>log_p_pri</em>, <em>log_p_gen</em>, <em>ncmod</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.PoPEx.add_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends a new model at the end of the model list and updates the
measure arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>imod</strong> (<em>int</em>) – Model index</li>
<li><strong>model</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">MType</span></code> instances defining a new model</li>
<li><strong>log_p_lik</strong> (<em>float</em>) – Log-likelihood value of model</li>
<li><strong>cmp_log_p_lik</strong> (<em>bool</em>) – Indicates if the log-likelihood has been computed (True) or
predicted (False)</li>
<li><strong>log_p_pri</strong> (<em>float</em>) – Log-prior value of model</li>
<li><strong>log_p_gen</strong> (<em>float</em>) – Log-generation value of model</li>
<li><strong>ncmod</strong> (<em>m-tuple</em>) – Defines the number of conditioning points that have been used in the
generation of the model</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="popex.popex_objects.PoPEx.insert_model">
<code class="descname">insert_model</code><span class="sig-paren">(</span><em>loc</em>, <em>imod</em>, <em>model</em>, <em>log_p_lik</em>, <em>cmp_log_p_lik</em>, <em>log_p_pri</em>, <em>log_p_gen</em>, <em>ncmod</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.PoPEx.insert_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a new model at <cite>loc</cite> of the model list and  updates the
measure arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loc</strong> (<em>int</em>) – Location of the insertion</li>
<li><strong>imod</strong> (<em>int</em>) – Model index</li>
<li><strong>model</strong> (<em>m-tuple</em>) – Tuple of <code class="docutils literal notranslate"><span class="pre">MType</span></code> instances defining a model</li>
<li><strong>log_p_lik</strong> (<em>float</em>) – Log-likelihood value of model</li>
<li><strong>cmp_log_p_lik</strong> (<em>bool</em>) – Indicates if the log-likelihood has been computed (True) or
predicted (False)</li>
<li><strong>log_p_pri</strong> (<em>float</em>) – Log-prior value of model</li>
<li><strong>log_p_gen</strong> (<em>float</em>) – Log-generation value of model</li>
<li><strong>ncmod</strong> (<em>m-tuple</em><em>)</em>) – Defines the number of conditioning points that have been used in the
generation of the model</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="popex.popex_objects.PoPEx.nmod">
<code class="descname">nmod</code><a class="headerlink" href="#popex.popex_objects.PoPEx.nmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Number of models in <cite>model</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.Prediction">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">Prediction</code><span class="sig-paren">(</span><em>compute_pred=None</em>, <em>meth_w_pred=None</em>, <em>nw_min=None</em>, <em>wfrac_pred=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.Prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a prediction that should be computed based on an existing
PoPEx instance.</p>
<p>The user must provide function definitions for <cite>compute_pred</cite> that actually
implements the prediction operator. Note that there is no return value
expected from that function. Any important result can be saved under</p>
<blockquote>
<div><div class="line-block">
<div class="line">&lt;path_res&gt;$</div>
<div class="line-block">
<div class="line">└– solution</div>
<div class="line-block">
<div class="line">└– pred_&lt;name&gt;_modXXXXXX</div>
</div>
</div>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>compute_pred</strong> (<em>function</em>) – <p>Computes the prediction for a given model.</p>
<p><cite>compute_pred(popex, imod)</cite></p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>popex <span class="classifier-delimiter">:</span> <span class="classifier">PoPEx</span></dt>
<dd>PoPEx main structure (cf <a class="reference internal" href="#popex.popex_objects.PoPEx" title="popex.popex_objects.PoPEx"><code class="xref py py-class docutils literal notranslate"><span class="pre">popex.popex_objects.PoPEx</span></code></a>)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>imod <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Model index</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</li>
<li><strong>meth_w_pred</strong> (<em>dict</em>) – Defines the method used for computing the prediction weights (cf.
<a class="reference internal" href="#popex.utils.compute_w_lik" title="popex.utils.compute_w_lik"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popex.utils.compute_w_lik()</span></code></a>)</li>
<li><strong>nw_min</strong> (<em>float</em>) – Minimum number of effective weights (= l_0)</li>
<li><strong>wfrac_pred</strong> (<em>float</em>) – Number in (0,1] defining the fraction of the total weight to be used for
the prediction. If <cite>p=1</cite>, all predictions for any model that has
non-zero weight is computed. If <cite>p&lt;1</cite> we take the minimum number of
weight to cover a ratio of <cite>p</cite> of the total sum of weights.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="popex.popex_objects.Problem">
<em class="property">class </em><code class="descclassname">popex.popex_objects.</code><code class="descname">Problem</code><span class="sig-paren">(</span><em>generate_m</em>, <em>compute_log_p_lik</em>, <em>get_hd_pri</em>, <em>compute_log_p_pri=None</em>, <em>compute_log_p_gen=None</em>, <em>learning_scheme=None</em>, <em>meth_w_hd=None</em>, <em>nmtype=1</em>, <em>seed=0</em><span class="sig-paren">)</span><a class="headerlink" href="#popex.popex_objects.Problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the sampling problem that should be addressed by the PoPEx
method.</p>
<p>The user must provide function definitions for <cite>generate_m</cite> and
<cite>compute_log_p_lik</cite>. For the definition of the model space, we can also
provide ‘prior hard conditioning’ through the function <cite>get_hd_pri</cite>.
Optionally, a likelihood learning scheme can be defined in
<cite>learning_scheme</cite>. Furthermore, one also must define how to compute the
ratio in the importance sampling weights. For this, the functions
<cite>compute_log_p_pri</cite> and <cite>compute_log_p_gen</cite> can also be defined manually. If
they are left empty, the default version that only considers the hard
conditioning data points is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>generate_m</strong> (<em>function</em>) – <p>Generates a new model m from a set of hard conditioning data.</p>
<p><cite>generate_m(hd_param_ind, hd_param_val, imod)</cite></p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>hd_param_ind <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>For each instance in the model tuple, this variable defines the
hard conditioning INDICES (where to apply HD). <cite>hd_param_ind[i]</cite>
is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nhd_i,)</cite></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_param_val <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>For each instance in the model tuple, this variable defines the
hard conditioning VALUES (what to imposed). <cite>hd_param_val[i]</cite> is
an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nhd_i,)</cite></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>imod <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Model index</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>m-tuple</dt>
<dd>New model such as <cite>(CatParam_1, …, CatParam_m)</cite></dd>
</dl>
</dd>
</dl>
</li>
<li><strong>compute_log_p_lik</strong> (<em>function</em>) – <p>Computes the natural logarithm of the likelihood of a model. It usually
runs an expensive forward operation and compares the response to a given
set of observations.</p>
<p><cite>compute_log_p_lik(model, imod)</cite></p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Model such as <cite>(CatParam_1, …, CatParam_m)</cite> (cf. output of
<cite>generate_m()</cite>)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>imod <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Model index</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>Log-likelihood value of the model</dd>
</dl>
</dd>
</dl>
</li>
<li><strong>get_hd_pri</strong> (<em>function</em>) – <p>Provides the ‘prior hard conditioning’ that is used in the definition of
the model space (i.e. parameter values that are known without
uncertainty).</p>
<p><cite>get_hd_pri()</cite></p>
<dl class="docutils">
<dt>Returns</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>hd_pri_ind <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>For each instance in the model tuple, this variable defines the
hard conditioning INDICES.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_pri_val <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>For each instance in the model tuple, this variable defines the
hard conditioning VALUES.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><strong>compute_log_p_pri</strong> (<em>function</em><em>, </em><em>optional</em>) – <p>This function computes the log-prior probability of a model that has
been generated from a given set of hard conditioning data. Note that
it’s definition is OPTIONAL. If it is left undefined, a default
implementation will be used (see remark below).</p>
<p><cite>compute_log_p_pri(model, hd_p_pri, hd_param_ind)</cite></p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Model such as <cite>(CatParam_1, …, CatParam_m)</cite> (cf. output of
<cite>generate_m()</cite>)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_p_pri <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Tuple of the hard conditioning probability values for a given
model. Each probability value describes the prior probability of
observing the category of the model value at the corresponding
conditioning location.
hd_p_pri[i] is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of <cite>shape=(nhd_i,)</cite></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_param_ind <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Hard conditioning indices</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>Log-prior probability value</dd>
</dl>
</dd>
</dl>
</li>
<li><strong>compute_log_p_gen</strong> (<em>function</em><em>, </em><em>optional</em>) – <p>This function computes the log-probability of generating a model in the
PoPEx sampling from a given set of hard conditioning. Note that it’s
definition is OPTIONAL. If it is left undefined, a default
implementation will be used (see remark below).</p>
<p><cite>compute_log_p_gen(model, hd_p_gen, hd_param_ind)</cite></p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Model such as <cite>(CatParam_1, …, CatParam_m)</cite> (cf. output of
<cite>generate_m()</cite>)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_p_gen <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Tuple of the hard conditioning probability values for a given
model. Each probability value describes the prior probability of
observing the category of the model value at the corresponding
conditioning location. <cite>hd_p_gen[i]</cite> is an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of
<cite>shape=(nhd_i,)</cite></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hd_param_ind <span class="classifier-delimiter">:</span> <span class="classifier">m-tuple</span></dt>
<dd>Hard conditioning indices</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>Log-generation probability value</dd>
</dl>
</dd>
</dl>
</li>
<li><strong>learning_scheme</strong> (<a class="reference internal" href="#popex.popex_objects.Learning" title="popex.popex_objects.Learning"><em>Learning</em></a><em>, </em><em>optional</em>) – Learning scheme for log_p_lik (concrete sublcass of <code class="docutils literal notranslate"><span class="pre">Learning</span></code>)</li>
<li><strong>meth_w_hd</strong> (<em>dict</em><em>, </em><em>optional</em>) – Defines the method for computing the learning weights that are used in
the computation of the hard conditioning points (cf.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_w_lik()</span></code>)</li>
<li><strong>nmtype</strong> (<em>int</em>) – Number of model types</li>
<li><strong>seed</strong> (<em>int</em>) – Initial seed</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic">
<li><p class="first">Let us provide a simple example for hard conditioning data in
<cite>hd_param_ind</cite> and <cite>hd_param_val</cite>. It is important to note that PoPEx
does NOT use any parameter locations. They might be defined by the
user. If so, they have to follow a certain structure. Let the parameter
locations be such that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                            <span class="n">x</span>    <span class="n">y</span>    <span class="n">z</span>
<span class="n">param_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>   <span class="c1"># Parameter 0</span>
                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>   <span class="c1"># Parameter 1</span>
                         <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>   <span class="c1"># Parameter 2</span>
</pre></div>
</div>
<p>and the parameter indices (in <cite>hd_param_ind</cite>) are for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hd_param_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>    <span class="c1"># Condition parameter 0 and 2</span>
</pre></div>
</div>
<p>so we will use <cite>param_loc[0][hd_param_ind[0], :]</cite> for obtaining the
array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
          <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span><span class="o">.</span>
</pre></div>
</div>
<p>This array indicates the physical locations where hard conditioning
should be applied for the model type <cite>0</cite>. Let the parameter values
(in <cite>hd_param_val</cite>) be given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hd_param_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span><span class="o">.</span>
</pre></div>
</div>
<p>Together with the conditioning locations above, this imposes hard
conditioning data as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">x</span>     <span class="n">y</span>     <span class="n">z</span>     <span class="n">val</span>
<span class="mf">0.5</span>   <span class="mf">1.5</span>   <span class="mf">0.5</span>    <span class="mf">1.2</span>
<span class="mf">0.5</span>   <span class="mf">3.5</span>   <span class="mf">0.5</span>    <span class="mf">2.5</span>
</pre></div>
</div>
</li>
<li><p class="first">Note that it is possible to NOT define <cite>compute_log_p_pri</cite> and
<cite>compute_log_p_gen</cite>. In this case, a predefined function will be used.
This predefined implementation assumes that the quantities <cite>p_pri</cite> and
<cite>p_gen</cite> are only used TOGETHER in the form of a RATIO</p>
<blockquote>
<div><p><cite>ratio(m) = rho(m) / phi(m)</cite>.</p>
</div></blockquote>
<p>In other words, the default functions assume that we are only interested
in the DIFFERENCE of the log values, i.e.</p>
<blockquote>
<div><p><cite>log_p_pri - log_p_gen</cite>,</p>
</div></blockquote>
<p>and never in the exact values on their own. It is left to the user to
implement a more suitable computation, whenever the above assumption is
not sufficient. For more information also consult the theoretical
description of the PoPEx method.</p>
</li>
<li><p class="first">It is also possible to NOT define the <cite>learning_scheme</cite>. In this case,
the log-likelihood value will ALWAYS be computed.</p>
</li>
</ol>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to PoPEx’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Christoph Jaeggli

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>